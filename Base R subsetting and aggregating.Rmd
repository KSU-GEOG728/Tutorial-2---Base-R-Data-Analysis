---
title: "Base R subsetting and aggregating"
author: "Kate Nelson"
date: "1/26/2022"
output:
  slidy_presentation: default
  powerpoint_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Today's Objectives

- Learn how to apply functions to multiple items using `apply()` functions. 
- Know how to subset dataframes using the `subset()` function.
- Be able to order and aggregate data using base R functions.
- Be able to create a Github account and link it to our class Github page.
- Create a repository in Github and be able to commit updates to code files using version control to the repo.

## Apply!

```{r, echo=FALSE, message=FALSE, warning=FALSE}

library(tidyverse)
data(iris)

```

Very often you may want to apply a function to multiple variables in a dataframe. You could do this one-by-one, or you could use a function that applies other functions across a vector.

  - The `apply()` function will return a vector of responses from applying a function across a dataframe, matrix, or vector.
  - `lapply()` does the same thing but operates on, and returns, lists.
  - `sapply()` can operate on a list, vector, or dataframe and returns a vector or matrix.
  - `tapply()` applies a function to groups in a vector according to an associated factor variable and returns a vector.
- This family of functions is great for speeding up repetitive calculations.
  
## Apply Examples 

I'll use the `apply()` functions on the demo dataset `iris`.

```{r iris}

glimpse(iris)

```

- We can calculate the average value for each numeric variable. 

  `var_ave <- apply(iris[ ,-5], MARGIN = 2, FUN = mean)` returns:
  `r var_ave <- apply(iris[ ,-5], MARGIN = 2, FUN = mean)` 
  `r var_ave`
    - `[ ,-5]` tells R to remove the 5th variable, which happens to be a factor and something to which you should not try to take an average. The `MARGIN` argument tells R to apply teh function to **columns** (The 2nd dimension).
  - Note that this returns as vector. `is.vector(var_ave)` returns `r is.vector(var_ave)`
- Doing the same thing using `lapply()` gives the same results but in a list format. (Note we do not have to specify a MARGIN argument here. `lapply` defaults to operations on columns.)
  - `var_ave <- lapply(iris[ ,-5],  FUN = mean)` `is.list(var_ave)` returns:
  
  `r var_ave <- lapply(iris[ ,-5],  FUN = mean)` `r var_ave` and `r is.list(var_ave)`
  
- In this case `sapply()` should yield the same results as `apply()`. 
- Use `tapply()` to calculate the average of "Petal.Width" by "Species".

  `spec_pw <- tapply(iris$Petal.Width, INDEX = iris$Species, FUN = mean)` gives
  
  `r spec_pw <- tapply(iris$Petal.Width, INDEX = iris$Species, FUN = mean)` `r spec_pw`
  

## Subsetting using `subset()`

You now know how to subset using R indexing but *base R* also includes a function for subsetting.

- `subset()` allows you create a subset across both rows (`subset` argument) and columns (`select` argument) of a dataframe
  - For example, we can pull out just records for a single species and keep just the columns on petal attributes.
  
  `petals_vir <- subset(iris, subset = Species == "virginica", select = c("Petal.Width", "Petal.Length", "Species"))` returns a dataset like this:
  
```{r subset}

petals_vir <- subset(iris, subset = Species == "virginica", select = c("Petal.Width", "Petal.Length", "Species"))
head(petals_vir)

```
  
  
## Ordering

Sometimes you may want to sort or order your data to display larger values first, etc... (This is often a nice addition to plots.)

- We can use `order()` to do this on vectors or dataframes.
- `sort()` can be used to order values as well but does not work on dataframes.
- Note that these functions sort in ascending order by default and return a vector of index values, not the rearragned dataset, so must be used in conjunction with *base R* indexing.
  - For example, we can arrange the `iris` data so it's in ascending order by "Petal.Width".
  
  `iris[order(iris$Petal.Width), ]` returns a dataset like this:
  
```{r order}

  head(iris[order(iris$Petal.Width), ])

```

  - This code tell R that we want to return the `iris` dataset, but with our x dimension (rows) reorganized so that Petal.Width is in ascending order, and that we want to keep everything in the y dimension (columns).
  - If we just did `order(iris$Petal.Width)` R will return the record/row index values in the new desired order. 
  
  E.g.  `r head(order(iris$Petal.Width))`
  
  - We could use `sort()` on a single variable of the dataframe.
  
  `sort(iris$Petal.Width, decreasing = TRUE)` will return:
  
  `r head(sort(iris$Petal.Width, decreasing = TRUE))`
  
  - We can use the argument `decreasing = TRUE` to sort in descending order.
- `sort()` and `order()` also work on character strings to sort things alphabetically!

## Aggregating

Aggregation is one of the most basic and useful techniques for summarizing and describing information. Technically if you wanted to produce descriptive statistics for every county in the US you could create a county subset of the data then calculate your statistics (mean, standard deviation, etc...) for each county subset. However, that's a pain. R let's us simplify this.

- `tapply()` is technically an aggregation function. It allows you to aggregate information about groups of data in a variable.
- The `aggregate()` function is another lovely way to do this that is easy to apply across multiple variables.
  - For example, to calculate the average value for the numeric variables in `iris` within each "Species" group.
  
  `means_iris <- aggregate(iris[ , -5], by = iris["Species"], FUN = mean)` gives the following summary dataset:

```{r agg}

  means_iris <- aggregate(iris[ , -5], by = iris["Species"], FUN = mean)
  means_iris

```


  - This tells R to take the average of all values for each variable except "Species" within or by each "Species" group.

  



  

